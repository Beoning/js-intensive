/* ------- #1 -------
   1. При нажатии event loop закинет оба обработчика в очередь макротасок в порядке их написания: 
      первый, затем второй сверху вниз; Так как event loop работает по принципу FIFO, то выполняться будет
      первый eventListener, попавший в очередь макротасок.
   2. Дальше event loop пройдется по первому листенеру, увидит промис и закинет его в очередь микротасок,
      а консоль лог закинет в стек и сразу его выполнит, так как это синхронная операция. Первым в консоль
      выведется Listener 1.
   3. Макротаски выполняются только если очередь микротасок пуста и по одной за раз. В очереди микротасок сейчас лежит промис,
      поэтому выполнится код в этом промисе, консоль лог попадет в стек и выполнится, выведется Microtask 1.
   4. Так как теперь очередь микротасок пуста, начнет выполняться код во втором листенере. Event loop также
      пройдя по коду закинет промис в очередь микротасок, а консоль лог закинет в стек и сразу выполнит, поэтому
      третьим в консоль выведется Listener 2.
   5. Последним выполнится оставшийся в очереди микротасок промис, консоль лог попадет в стек и выполнится, выведется
      Microtask 2.
   Порядок вывода в консоль: Listener 1, Microtask 1, Listener 2, Microtask 2
*/

/* ------- #2 -------
  Изначально я думал, что при button.click() разницы при выводе в консоль с первым заданием не будет, 
  но я запустил код и сейчас попробую обьяснить почему вывод отличается;
  
  Как мне кажется разница в том, что во втором случае при вызове метода click() на кнопке у нас код обработчиков возвращается
  как синхронный, так как сам click() вызывается синхронно. То есть при вызове click() у нас в стеке будут две синхронные функции. 
  Далее по порядку: у первого обработчика выполнится первый консоль лог (Listener 1), а в очередь микротасок попадет промис. Так как
  в стеке лежит коллбек функция второго обработчика (стек не пустой), то начнет выполнятся код второго обработчика, а не микротаска,
  выведется второй консоль лог (Listener 2), а промис попадет в очередь микротасок следом за первым промисом. Дальше, 
  так как стек пуст, начнут выполняться микротаски в порядке попадания в очередь микротасок. Вывеоедтся сначала Microtask 1, 
  потом Microtask 2. 
  Проще говоря, разница в том, что в первом случае функции попадают в web api, и обрабатываются как макротаски, а во втором функции
  попадают в стек и выполняются синхронно.
  Порядок вывода в консоль: Listener 1, Listener 2, Microtask 1, Microtask 2

*/
